package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/dog-sky/dog_bot/internal/service/db.DB -o ./mocks/db_minimock.go -n DBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/dog-sky/dog_bot/internal/service/db/models"
	desc "github.com/dog-sky/dog_bot/pkg/dog/api"
	"github.com/gojuno/minimock/v3"
)

// DBMock implements db.DB
type DBMock struct {
	t minimock.Tester

	funcSetStatus          func(ctx context.Context, status string) (err error)
	inspectFuncSetStatus   func(ctx context.Context, status string)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mDBMockSetStatus

	funcShutDown          func()
	inspectFuncShutDown   func()
	afterShutDownCounter  uint64
	beforeShutDownCounter uint64
	ShutDownMock          mDBMockShutDown

	funcStatusList          func(ctx context.Context, filter *models.Filter) (spa1 []*desc.StatusListReply_Action, err error)
	inspectFuncStatusList   func(ctx context.Context, filter *models.Filter)
	afterStatusListCounter  uint64
	beforeStatusListCounter uint64
	StatusListMock          mDBMockStatusList
}

// NewDBMock returns a mock for db.DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SetStatusMock = mDBMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*DBMockSetStatusParams{}

	m.ShutDownMock = mDBMockShutDown{mock: m}

	m.StatusListMock = mDBMockStatusList{mock: m}
	m.StatusListMock.callArgs = []*DBMockStatusListParams{}

	return m
}

type mDBMockSetStatus struct {
	mock               *DBMock
	defaultExpectation *DBMockSetStatusExpectation
	expectations       []*DBMockSetStatusExpectation

	callArgs []*DBMockSetStatusParams
	mutex    sync.RWMutex
}

// DBMockSetStatusExpectation specifies expectation struct of the DB.SetStatus
type DBMockSetStatusExpectation struct {
	mock    *DBMock
	params  *DBMockSetStatusParams
	results *DBMockSetStatusResults
	Counter uint64
}

// DBMockSetStatusParams contains parameters of the DB.SetStatus
type DBMockSetStatusParams struct {
	ctx    context.Context
	status string
}

// DBMockSetStatusResults contains results of the DB.SetStatus
type DBMockSetStatusResults struct {
	err error
}

// Expect sets up expected params for DB.SetStatus
func (mmSetStatus *mDBMockSetStatus) Expect(ctx context.Context, status string) *mDBMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("DBMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &DBMockSetStatusExpectation{}
	}

	mmSetStatus.defaultExpectation.params = &DBMockSetStatusParams{ctx, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the DB.SetStatus
func (mmSetStatus *mDBMockSetStatus) Inspect(f func(ctx context.Context, status string)) *mDBMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for DBMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by DB.SetStatus
func (mmSetStatus *mDBMockSetStatus) Return(err error) *DBMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("DBMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &DBMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &DBMockSetStatusResults{err}
	return mmSetStatus.mock
}

//Set uses given function f to mock the DB.SetStatus method
func (mmSetStatus *mDBMockSetStatus) Set(f func(ctx context.Context, status string) (err error)) *DBMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the DB.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the DB.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the DB.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mDBMockSetStatus) When(ctx context.Context, status string) *DBMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("DBMock.SetStatus mock is already set by Set")
	}

	expectation := &DBMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &DBMockSetStatusParams{ctx, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up DB.SetStatus return parameters for the expectation previously defined by the When method
func (e *DBMockSetStatusExpectation) Then(err error) *DBMock {
	e.results = &DBMockSetStatusResults{err}
	return e.mock
}

// SetStatus implements db.DB
func (mmSetStatus *DBMock) SetStatus(ctx context.Context, status string) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, status)
	}

	mm_params := &DBMockSetStatusParams{ctx, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_got := DBMockSetStatusParams{ctx, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("DBMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the DBMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to DBMock.SetStatus. %v %v", ctx, status)
	return
}

// SetStatusAfterCounter returns a count of finished DBMock.SetStatus invocations
func (mmSetStatus *DBMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of DBMock.SetStatus invocations
func (mmSetStatus *DBMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to DBMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mDBMockSetStatus) Calls() []*DBMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*DBMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockSetStatusDone() bool {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *DBMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.SetStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to DBMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && mm_atomic.LoadUint64(&m.afterSetStatusCounter) < 1 {
		m.t.Error("Expected call to DBMock.SetStatus")
	}
}

type mDBMockShutDown struct {
	mock               *DBMock
	defaultExpectation *DBMockShutDownExpectation
	expectations       []*DBMockShutDownExpectation
}

// DBMockShutDownExpectation specifies expectation struct of the DB.ShutDown
type DBMockShutDownExpectation struct {
	mock *DBMock

	Counter uint64
}

// Expect sets up expected params for DB.ShutDown
func (mmShutDown *mDBMockShutDown) Expect() *mDBMockShutDown {
	if mmShutDown.mock.funcShutDown != nil {
		mmShutDown.mock.t.Fatalf("DBMock.ShutDown mock is already set by Set")
	}

	if mmShutDown.defaultExpectation == nil {
		mmShutDown.defaultExpectation = &DBMockShutDownExpectation{}
	}

	return mmShutDown
}

// Inspect accepts an inspector function that has same arguments as the DB.ShutDown
func (mmShutDown *mDBMockShutDown) Inspect(f func()) *mDBMockShutDown {
	if mmShutDown.mock.inspectFuncShutDown != nil {
		mmShutDown.mock.t.Fatalf("Inspect function is already set for DBMock.ShutDown")
	}

	mmShutDown.mock.inspectFuncShutDown = f

	return mmShutDown
}

// Return sets up results that will be returned by DB.ShutDown
func (mmShutDown *mDBMockShutDown) Return() *DBMock {
	if mmShutDown.mock.funcShutDown != nil {
		mmShutDown.mock.t.Fatalf("DBMock.ShutDown mock is already set by Set")
	}

	if mmShutDown.defaultExpectation == nil {
		mmShutDown.defaultExpectation = &DBMockShutDownExpectation{mock: mmShutDown.mock}
	}

	return mmShutDown.mock
}

//Set uses given function f to mock the DB.ShutDown method
func (mmShutDown *mDBMockShutDown) Set(f func()) *DBMock {
	if mmShutDown.defaultExpectation != nil {
		mmShutDown.mock.t.Fatalf("Default expectation is already set for the DB.ShutDown method")
	}

	if len(mmShutDown.expectations) > 0 {
		mmShutDown.mock.t.Fatalf("Some expectations are already set for the DB.ShutDown method")
	}

	mmShutDown.mock.funcShutDown = f
	return mmShutDown.mock
}

// ShutDown implements db.DB
func (mmShutDown *DBMock) ShutDown() {
	mm_atomic.AddUint64(&mmShutDown.beforeShutDownCounter, 1)
	defer mm_atomic.AddUint64(&mmShutDown.afterShutDownCounter, 1)

	if mmShutDown.inspectFuncShutDown != nil {
		mmShutDown.inspectFuncShutDown()
	}

	if mmShutDown.ShutDownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShutDown.ShutDownMock.defaultExpectation.Counter, 1)

		return

	}
	if mmShutDown.funcShutDown != nil {
		mmShutDown.funcShutDown()
		return
	}
	mmShutDown.t.Fatalf("Unexpected call to DBMock.ShutDown.")

}

// ShutDownAfterCounter returns a count of finished DBMock.ShutDown invocations
func (mmShutDown *DBMock) ShutDownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutDown.afterShutDownCounter)
}

// ShutDownBeforeCounter returns a count of DBMock.ShutDown invocations
func (mmShutDown *DBMock) ShutDownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutDown.beforeShutDownCounter)
}

// MinimockShutDownDone returns true if the count of the ShutDown invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockShutDownDone() bool {
	for _, e := range m.ShutDownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShutDownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShutDownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutDown != nil && mm_atomic.LoadUint64(&m.afterShutDownCounter) < 1 {
		return false
	}
	return true
}

// MinimockShutDownInspect logs each unmet expectation
func (m *DBMock) MinimockShutDownInspect() {
	for _, e := range m.ShutDownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.ShutDown")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShutDownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShutDownCounter) < 1 {
		m.t.Error("Expected call to DBMock.ShutDown")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutDown != nil && mm_atomic.LoadUint64(&m.afterShutDownCounter) < 1 {
		m.t.Error("Expected call to DBMock.ShutDown")
	}
}

type mDBMockStatusList struct {
	mock               *DBMock
	defaultExpectation *DBMockStatusListExpectation
	expectations       []*DBMockStatusListExpectation

	callArgs []*DBMockStatusListParams
	mutex    sync.RWMutex
}

// DBMockStatusListExpectation specifies expectation struct of the DB.StatusList
type DBMockStatusListExpectation struct {
	mock    *DBMock
	params  *DBMockStatusListParams
	results *DBMockStatusListResults
	Counter uint64
}

// DBMockStatusListParams contains parameters of the DB.StatusList
type DBMockStatusListParams struct {
	ctx    context.Context
	filter *models.Filter
}

// DBMockStatusListResults contains results of the DB.StatusList
type DBMockStatusListResults struct {
	spa1 []*desc.StatusListReply_Action
	err  error
}

// Expect sets up expected params for DB.StatusList
func (mmStatusList *mDBMockStatusList) Expect(ctx context.Context, filter *models.Filter) *mDBMockStatusList {
	if mmStatusList.mock.funcStatusList != nil {
		mmStatusList.mock.t.Fatalf("DBMock.StatusList mock is already set by Set")
	}

	if mmStatusList.defaultExpectation == nil {
		mmStatusList.defaultExpectation = &DBMockStatusListExpectation{}
	}

	mmStatusList.defaultExpectation.params = &DBMockStatusListParams{ctx, filter}
	for _, e := range mmStatusList.expectations {
		if minimock.Equal(e.params, mmStatusList.defaultExpectation.params) {
			mmStatusList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatusList.defaultExpectation.params)
		}
	}

	return mmStatusList
}

// Inspect accepts an inspector function that has same arguments as the DB.StatusList
func (mmStatusList *mDBMockStatusList) Inspect(f func(ctx context.Context, filter *models.Filter)) *mDBMockStatusList {
	if mmStatusList.mock.inspectFuncStatusList != nil {
		mmStatusList.mock.t.Fatalf("Inspect function is already set for DBMock.StatusList")
	}

	mmStatusList.mock.inspectFuncStatusList = f

	return mmStatusList
}

// Return sets up results that will be returned by DB.StatusList
func (mmStatusList *mDBMockStatusList) Return(spa1 []*desc.StatusListReply_Action, err error) *DBMock {
	if mmStatusList.mock.funcStatusList != nil {
		mmStatusList.mock.t.Fatalf("DBMock.StatusList mock is already set by Set")
	}

	if mmStatusList.defaultExpectation == nil {
		mmStatusList.defaultExpectation = &DBMockStatusListExpectation{mock: mmStatusList.mock}
	}
	mmStatusList.defaultExpectation.results = &DBMockStatusListResults{spa1, err}
	return mmStatusList.mock
}

//Set uses given function f to mock the DB.StatusList method
func (mmStatusList *mDBMockStatusList) Set(f func(ctx context.Context, filter *models.Filter) (spa1 []*desc.StatusListReply_Action, err error)) *DBMock {
	if mmStatusList.defaultExpectation != nil {
		mmStatusList.mock.t.Fatalf("Default expectation is already set for the DB.StatusList method")
	}

	if len(mmStatusList.expectations) > 0 {
		mmStatusList.mock.t.Fatalf("Some expectations are already set for the DB.StatusList method")
	}

	mmStatusList.mock.funcStatusList = f
	return mmStatusList.mock
}

// When sets expectation for the DB.StatusList which will trigger the result defined by the following
// Then helper
func (mmStatusList *mDBMockStatusList) When(ctx context.Context, filter *models.Filter) *DBMockStatusListExpectation {
	if mmStatusList.mock.funcStatusList != nil {
		mmStatusList.mock.t.Fatalf("DBMock.StatusList mock is already set by Set")
	}

	expectation := &DBMockStatusListExpectation{
		mock:   mmStatusList.mock,
		params: &DBMockStatusListParams{ctx, filter},
	}
	mmStatusList.expectations = append(mmStatusList.expectations, expectation)
	return expectation
}

// Then sets up DB.StatusList return parameters for the expectation previously defined by the When method
func (e *DBMockStatusListExpectation) Then(spa1 []*desc.StatusListReply_Action, err error) *DBMock {
	e.results = &DBMockStatusListResults{spa1, err}
	return e.mock
}

// StatusList implements db.DB
func (mmStatusList *DBMock) StatusList(ctx context.Context, filter *models.Filter) (spa1 []*desc.StatusListReply_Action, err error) {
	mm_atomic.AddUint64(&mmStatusList.beforeStatusListCounter, 1)
	defer mm_atomic.AddUint64(&mmStatusList.afterStatusListCounter, 1)

	if mmStatusList.inspectFuncStatusList != nil {
		mmStatusList.inspectFuncStatusList(ctx, filter)
	}

	mm_params := &DBMockStatusListParams{ctx, filter}

	// Record call args
	mmStatusList.StatusListMock.mutex.Lock()
	mmStatusList.StatusListMock.callArgs = append(mmStatusList.StatusListMock.callArgs, mm_params)
	mmStatusList.StatusListMock.mutex.Unlock()

	for _, e := range mmStatusList.StatusListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.err
		}
	}

	if mmStatusList.StatusListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatusList.StatusListMock.defaultExpectation.Counter, 1)
		mm_want := mmStatusList.StatusListMock.defaultExpectation.params
		mm_got := DBMockStatusListParams{ctx, filter}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatusList.t.Errorf("DBMock.StatusList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatusList.StatusListMock.defaultExpectation.results
		if mm_results == nil {
			mmStatusList.t.Fatal("No results are set for the DBMock.StatusList")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmStatusList.funcStatusList != nil {
		return mmStatusList.funcStatusList(ctx, filter)
	}
	mmStatusList.t.Fatalf("Unexpected call to DBMock.StatusList. %v %v", ctx, filter)
	return
}

// StatusListAfterCounter returns a count of finished DBMock.StatusList invocations
func (mmStatusList *DBMock) StatusListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusList.afterStatusListCounter)
}

// StatusListBeforeCounter returns a count of DBMock.StatusList invocations
func (mmStatusList *DBMock) StatusListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusList.beforeStatusListCounter)
}

// Calls returns a list of arguments used in each call to DBMock.StatusList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatusList *mDBMockStatusList) Calls() []*DBMockStatusListParams {
	mmStatusList.mutex.RLock()

	argCopy := make([]*DBMockStatusListParams, len(mmStatusList.callArgs))
	copy(argCopy, mmStatusList.callArgs)

	mmStatusList.mutex.RUnlock()

	return argCopy
}

// MinimockStatusListDone returns true if the count of the StatusList invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockStatusListDone() bool {
	for _, e := range m.StatusListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatusListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatusListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatusList != nil && mm_atomic.LoadUint64(&m.afterStatusListCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatusListInspect logs each unmet expectation
func (m *DBMock) MinimockStatusListInspect() {
	for _, e := range m.StatusListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.StatusList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatusListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatusListCounter) < 1 {
		if m.StatusListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.StatusList")
		} else {
			m.t.Errorf("Expected call to DBMock.StatusList with params: %#v", *m.StatusListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatusList != nil && mm_atomic.LoadUint64(&m.afterStatusListCounter) < 1 {
		m.t.Error("Expected call to DBMock.StatusList")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockSetStatusInspect()

		m.MinimockShutDownInspect()

		m.MinimockStatusListInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSetStatusDone() &&
		m.MinimockShutDownDone() &&
		m.MinimockStatusListDone()
}
